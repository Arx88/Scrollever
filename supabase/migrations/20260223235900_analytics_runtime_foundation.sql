-- 20260223235900_analytics_runtime_foundation.sql
-- Runtime analytics foundation: canonical product events, visitor identity stitching,
-- qualified visitor conversion, retention cohorts, and admin-facing KPI catalog.

create extension if not exists pgcrypto;

create table if not exists public.product_events (
  id bigint generated by default as identity primary key,
  event_id uuid not null default gen_random_uuid(),
  event_name text not null check (char_length(trim(event_name)) > 0),
  event_time timestamptz not null,
  ingested_at timestamptz not null default now(),
  user_id uuid null references public.profiles(id) on delete set null,
  anonymous_id text null,
  session_id text null,
  source text null,
  path text null,
  referrer text null,
  user_agent text null,
  ip inet null,
  metadata jsonb not null default '{}'::jsonb,
  is_test_traffic boolean not null default false,
  is_bot boolean not null default false,
  constraint product_events_event_id_unique unique (event_id)
);

create index if not exists product_events_name_time_idx
  on public.product_events (event_name, event_time desc);

create index if not exists product_events_user_time_idx
  on public.product_events (user_id, event_time desc)
  where user_id is not null;

create index if not exists product_events_anonymous_time_idx
  on public.product_events (anonymous_id, event_time desc)
  where anonymous_id is not null;

create index if not exists product_events_session_time_idx
  on public.product_events (session_id, event_time desc)
  where session_id is not null;

create index if not exists product_events_ingested_idx
  on public.product_events (ingested_at desc);

alter table public.product_events enable row level security;

drop policy if exists "product_events_insert_client" on public.product_events;
create policy "product_events_insert_client"
  on public.product_events
  for insert
  to anon, authenticated
  with check (
    (
      auth.uid() is null
      and user_id is null
    )
    or
    (
      auth.uid() is not null
      and (user_id is null or user_id = auth.uid())
    )
  );

drop policy if exists "product_events_select_moderator" on public.product_events;
create policy "product_events_select_moderator"
  on public.product_events
  for select
  to authenticated
  using (public.is_moderator());

drop policy if exists "product_events_delete_admin" on public.product_events;
create policy "product_events_delete_admin"
  on public.product_events
  for delete
  to authenticated
  using (public.is_admin());

create table if not exists public.identity_links (
  anonymous_id text not null,
  user_id uuid not null references public.profiles(id) on delete cascade,
  linked_at timestamptz not null default now(),
  primary key (anonymous_id, user_id)
);

create index if not exists identity_links_user_linked_at_idx
  on public.identity_links (user_id, linked_at desc);

create index if not exists identity_links_anonymous_linked_at_idx
  on public.identity_links (anonymous_id, linked_at desc);

alter table public.identity_links enable row level security;

drop policy if exists "identity_links_select_owner_or_moderator" on public.identity_links;
create policy "identity_links_select_owner_or_moderator"
  on public.identity_links
  for select
  to authenticated
  using (auth.uid() = user_id or public.is_moderator());

drop policy if exists "identity_links_insert_own" on public.identity_links;
create policy "identity_links_insert_own"
  on public.identity_links
  for insert
  to authenticated
  with check (auth.uid() = user_id);

drop policy if exists "identity_links_delete_admin" on public.identity_links;
create policy "identity_links_delete_admin"
  on public.identity_links
  for delete
  to authenticated
  using (public.is_admin());

create table if not exists public.metric_catalog (
  metric_key text primary key,
  definition text not null,
  owner_role text not null check (
    owner_role in ('product', 'growth', 'creator_ops', 'moderation', 'engineering', 'admin')
  ),
  decision_playbook_url text null,
  sla_minutes integer not null check (sla_minutes > 0),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

drop trigger if exists set_metric_catalog_updated_at on public.metric_catalog;
create trigger set_metric_catalog_updated_at
before update on public.metric_catalog
for each row
execute function public.set_updated_at();

alter table public.metric_catalog enable row level security;

drop policy if exists "metric_catalog_select_moderator" on public.metric_catalog;
create policy "metric_catalog_select_moderator"
  on public.metric_catalog
  for select
  to authenticated
  using (public.is_moderator());

drop policy if exists "metric_catalog_write_admin" on public.metric_catalog;
create policy "metric_catalog_write_admin"
  on public.metric_catalog
  for all
  to authenticated
  using (public.is_admin())
  with check (public.is_admin());

create or replace function public.analytics_is_bot(p_user_agent text)
returns boolean
language sql
immutable
as $$
  select coalesce(p_user_agent, '') ~* '(bot|crawler|spider|headless|slurp|pingdom|uptime|monitor|curl|wget|python-requests)';
$$;

create or replace view public.identity_links_latest
with (security_invoker = true)
as
select ranked.anonymous_id, ranked.user_id, ranked.linked_at
from (
  select
    il.anonymous_id,
    il.user_id,
    il.linked_at,
    row_number() over (
      partition by il.anonymous_id
      order by il.linked_at desc, il.user_id asc
    ) as rn
  from public.identity_links il
) as ranked
where ranked.rn = 1;

create or replace view public.analytics_events_enriched
with (security_invoker = true)
as
select
  pe.event_id,
  pe.event_name,
  pe.event_time,
  pe.ingested_at,
  pe.user_id,
  pe.anonymous_id,
  pe.session_id,
  pe.source,
  pe.path,
  pe.referrer,
  pe.user_agent,
  pe.ip,
  pe.metadata,
  pe.is_test_traffic,
  pe.is_bot,
  il.user_id as linked_user_id,
  coalesce(pe.user_id, il.user_id) as resolved_user_id,
  coalesce(
    case when pe.user_id is not null then 'u:' || pe.user_id::text end,
    case when il.user_id is not null then 'u:' || il.user_id::text end,
    case when pe.anonymous_id is not null and trim(pe.anonymous_id) <> '' then 'a:' || pe.anonymous_id end
  ) as consolidated_visitor_id,
  (
    coalesce(pe.is_test_traffic, false)
    or coalesce(pe.is_bot, false)
    or public.analytics_is_bot(pe.user_agent)
  ) as is_filtered_traffic
from public.product_events pe
left join public.identity_links_latest il
  on il.anonymous_id = pe.anonymous_id;

create or replace view public.analytics_session_summaries
with (security_invoker = true)
as
select
  e.session_id,
  min(e.event_time) as session_started_at,
  max(e.event_time) as session_ended_at,
  greatest(
    0,
    extract(epoch from (max(e.event_time) - min(e.event_time)))
  )::integer as session_duration_seconds,
  count(*) filter (where e.event_name = 'page_view')::integer as page_view_count,
  bool_or(e.event_name = 'landing_viewed') as landing_viewed,
  bool_or(e.is_filtered_traffic) as is_filtered_traffic,
  (
    array_agg(e.consolidated_visitor_id order by e.event_time desc)
    filter (where e.consolidated_visitor_id is not null)
  )[1] as consolidated_visitor_id,
  (
    array_agg(e.resolved_user_id order by e.event_time desc)
    filter (where e.resolved_user_id is not null)
  )[1] as resolved_user_id,
  coalesce(
    (
      array_agg(e.source order by e.event_time asc)
      filter (where e.source is not null and trim(e.source) <> '')
    )[1],
    'direct'
  ) as source
from public.analytics_events_enriched e
where e.session_id is not null
group by e.session_id;

create or replace view public.analytics_qualified_visitors_daily
with (security_invoker = true)
as
select
  (s.session_started_at at time zone 'UTC')::date as metric_date,
  count(distinct s.consolidated_visitor_id) as qualified_visitors
from public.analytics_session_summaries s
where s.is_filtered_traffic = false
  and s.consolidated_visitor_id is not null
  and s.landing_viewed
  and (
    s.session_duration_seconds >= 10
    or s.page_view_count >= 2
  )
group by (s.session_started_at at time zone 'UTC')::date;

create or replace view public.analytics_signup_cohorts
with (security_invoker = true)
as
select
  e.resolved_user_id as user_id,
  min((e.event_time at time zone 'UTC')::date) as cohort_date
from public.analytics_events_enriched e
where e.event_name = 'signup_completed'
  and e.resolved_user_id is not null
  and e.is_filtered_traffic = false
group by e.resolved_user_id;

create or replace view public.analytics_active_user_days
with (security_invoker = true)
as
select distinct
  e.resolved_user_id as user_id,
  (e.event_time at time zone 'UTC')::date as activity_date
from public.analytics_events_enriched e
where e.resolved_user_id is not null
  and e.is_filtered_traffic = false
  and e.event_name in (
    'page_view',
    'like_added',
    'generation_job_started',
    'board_item_added'
  );

create or replace view public.analytics_retention_cohorts_daily
with (security_invoker = true)
as
with retained as (
  select
    c.cohort_date,
    c.user_id,
    bool_or(a.activity_date = c.cohort_date + 1) as retained_d1,
    bool_or(a.activity_date = c.cohort_date + 7) as retained_d7,
    bool_or(a.activity_date = c.cohort_date + 30) as retained_d30
  from public.analytics_signup_cohorts c
  left join public.analytics_active_user_days a
    on a.user_id = c.user_id
   and a.activity_date in (c.cohort_date + 1, c.cohort_date + 7, c.cohort_date + 30)
  group by c.cohort_date, c.user_id
)
select
  r.cohort_date,
  count(*)::bigint as cohort_size,
  sum(case when r.retained_d1 then 1 else 0 end)::bigint as retained_d1_users,
  sum(case when r.retained_d7 then 1 else 0 end)::bigint as retained_d7_users,
  sum(case when r.retained_d30 then 1 else 0 end)::bigint as retained_d30_users,
  round(
    100.0 * sum(case when r.retained_d1 then 1 else 0 end)::numeric / nullif(count(*), 0),
    2
  ) as d1_retention_pct,
  round(
    100.0 * sum(case when r.retained_d7 then 1 else 0 end)::numeric / nullif(count(*), 0),
    2
  ) as d7_retention_pct,
  round(
    100.0 * sum(case when r.retained_d30 then 1 else 0 end)::numeric / nullif(count(*), 0),
    2
  ) as d30_retention_pct,
  ((now() at time zone 'UTC')::date - r.cohort_date)::integer as cohort_age_days
from retained r
group by r.cohort_date
order by r.cohort_date desc;

create or replace view public.analytics_retention_cohorts_weekly
with (security_invoker = true)
as
select
  date_trunc('week', d.cohort_date)::date as cohort_week,
  sum(d.cohort_size)::bigint as cohort_size,
  round(
    100.0 * sum(d.retained_d1_users)::numeric / nullif(sum(d.cohort_size), 0),
    2
  ) as d1_retention_pct,
  round(
    100.0 * sum(d.retained_d7_users)::numeric / nullif(sum(d.cohort_size), 0),
    2
  ) as d7_retention_pct,
  round(
    100.0 * sum(d.retained_d30_users)::numeric / nullif(sum(d.cohort_size), 0),
    2
  ) as d30_retention_pct
from public.analytics_retention_cohorts_daily d
group by date_trunc('week', d.cohort_date)::date
order by cohort_week desc;

create or replace function public.get_analytics_window_summary(
  p_since timestamptz,
  p_until timestamptz default now()
)
returns table (
  visitors bigint,
  sessions bigint,
  qualified_visitors bigint,
  signup_completed bigint,
  page_views bigint
)
language sql
stable
set search_path = public
as $$
  with events as (
    select *
    from public.analytics_events_enriched e
    where e.event_time >= p_since
      and e.event_time < p_until
      and e.is_filtered_traffic = false
  ),
  sessions_window as (
    select *
    from public.analytics_session_summaries s
    where s.session_started_at >= p_since
      and s.session_started_at < p_until
      and s.is_filtered_traffic = false
  )
  select
    (
      select count(distinct e.consolidated_visitor_id)
      from events e
      where e.consolidated_visitor_id is not null
    )::bigint as visitors,
    (
      select count(distinct s.session_id)
      from sessions_window s
      where s.session_id is not null
    )::bigint as sessions,
    (
      select count(distinct s.consolidated_visitor_id)
      from sessions_window s
      where s.consolidated_visitor_id is not null
        and s.landing_viewed
        and (s.session_duration_seconds >= 10 or s.page_view_count >= 2)
    )::bigint as qualified_visitors,
    (
      select count(distinct e.resolved_user_id)
      from events e
      where e.event_name = 'signup_completed'
        and e.resolved_user_id is not null
    )::bigint as signup_completed,
    (
      select count(*)
      from events e
      where e.event_name = 'page_view'
    )::bigint as page_views;
$$;

create or replace function public.get_analytics_top_sources(
  p_since timestamptz,
  p_until timestamptz default now(),
  p_limit integer default 5
)
returns table (
  source text,
  sessions bigint,
  share_pct numeric
)
language sql
stable
set search_path = public
as $$
  with source_counts as (
    select
      coalesce(nullif(trim(s.source), ''), 'direct') as source,
      count(*)::bigint as sessions
    from public.analytics_session_summaries s
    where s.session_started_at >= p_since
      and s.session_started_at < p_until
      and s.is_filtered_traffic = false
    group by coalesce(nullif(trim(s.source), ''), 'direct')
  ),
  totals as (
    select coalesce(sum(sc.sessions), 0)::numeric as total_sessions
    from source_counts sc
  )
  select
    sc.source,
    sc.sessions,
    case
      when t.total_sessions <= 0 then 0::numeric
      else round((sc.sessions::numeric * 100.0) / t.total_sessions, 2)
    end as share_pct
  from source_counts sc
  cross join totals t
  order by sc.sessions desc, sc.source asc
  limit greatest(1, least(20, coalesce(p_limit, 5)));
$$;

create or replace function public.get_retention_snapshot(
  p_lookback_days integer default 120
)
returns table (
  d1_retention_pct numeric,
  d7_retention_pct numeric,
  d30_retention_pct numeric,
  matured_d1_cohorts bigint,
  matured_d7_cohorts bigint,
  matured_d30_cohorts bigint
)
language sql
stable
set search_path = public
as $$
  with base as (
    select *
    from public.analytics_retention_cohorts_daily r
    where r.cohort_date >= ((now() at time zone 'UTC')::date - greatest(30, coalesce(p_lookback_days, 120)))
  ),
  d1 as (
    select
      coalesce(sum(retained_d1_users), 0)::numeric as retained_users,
      coalesce(sum(cohort_size), 0)::numeric as cohort_users,
      count(*)::bigint as cohort_count
    from base
    where cohort_age_days >= 1
  ),
  d7 as (
    select
      coalesce(sum(retained_d7_users), 0)::numeric as retained_users,
      coalesce(sum(cohort_size), 0)::numeric as cohort_users,
      count(*)::bigint as cohort_count
    from base
    where cohort_age_days >= 7
  ),
  d30 as (
    select
      coalesce(sum(retained_d30_users), 0)::numeric as retained_users,
      coalesce(sum(cohort_size), 0)::numeric as cohort_users,
      count(*)::bigint as cohort_count
    from base
    where cohort_age_days >= 30
  )
  select
    case when d1.cohort_users <= 0 then 0::numeric else round((d1.retained_users * 100.0) / d1.cohort_users, 2) end as d1_retention_pct,
    case when d7.cohort_users <= 0 then 0::numeric else round((d7.retained_users * 100.0) / d7.cohort_users, 2) end as d7_retention_pct,
    case when d30.cohort_users <= 0 then 0::numeric else round((d30.retained_users * 100.0) / d30.cohort_users, 2) end as d30_retention_pct,
    d1.cohort_count as matured_d1_cohorts,
    d7.cohort_count as matured_d7_cohorts,
    d30.cohort_count as matured_d30_cohorts
  from d1
  cross join d7
  cross join d30;
$$;

create or replace function public.track_signup_completed_event()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.product_events (
    event_name,
    event_time,
    user_id,
    source,
    path,
    metadata,
    is_test_traffic,
    is_bot
  )
  values (
    'signup_completed',
    coalesce(new.created_at, now()),
    new.id,
    'signup',
    '/auth/sign-up',
    jsonb_build_object('origin', 'profiles_trigger'),
    false,
    false
  );

  return new;
end;
$$;

drop trigger if exists track_signup_completed_on_profiles on public.profiles;
create trigger track_signup_completed_on_profiles
after insert on public.profiles
for each row
execute function public.track_signup_completed_event();

insert into public.metric_catalog (metric_key, definition, owner_role, decision_playbook_url, sla_minutes)
values
  (
    'north_star_survival_quality',
    'Imagenes inmortales por cada 100 imagenes publicadas en 24h, ponderado por likes medianos y presion de corte.',
    'product',
    null,
    60
  ),
  (
    'qualified_signup_conversion',
    'Signups completados / qualified visitors. Qualified = landing_viewed y sesion >=10s o >=2 page views.',
    'growth',
    null,
    30
  ),
  (
    'retention_d7',
    'Retencion D7 por cohorte de signup usando active_user_day (page_view|like_added|generation_job_started|board_item_added).',
    'creator_ops',
    null,
    60
  ),
  (
    'superlike_concentration_hhi',
    'Concentracion de superlikes por creador para detectar sesgo de distribucion y riesgo de brigading.',
    'moderation',
    null,
    120
  )
on conflict (metric_key) do update
set
  definition = excluded.definition,
  owner_role = excluded.owner_role,
  decision_playbook_url = excluded.decision_playbook_url,
  sla_minutes = excluded.sla_minutes,
  updated_at = now();

insert into public.app_settings (key, value_json, value_type, category, description, is_public)
values
  (
    'analytics.events_enabled',
    'true'::jsonb,
    'boolean',
    'analytics',
    'Activa tracking de eventos de producto y vistas de conversion/retencion.',
    false
  ),
  (
    'analytics.backfill_window_hours',
    '72'::jsonb,
    'number',
    'analytics',
    'Ventana de backfill automatico cuando hay incidentes de ingestion.',
    false
  ),
  (
    'analytics.qualified_session_min_seconds',
    '10'::jsonb,
    'number',
    'analytics',
    'Segundos minimos para considerar sesion calificada si no llega a 2 page views.',
    false
  )
on conflict (key) do update
set
  value_json = excluded.value_json,
  value_type = excluded.value_type,
  category = excluded.category,
  description = excluded.description,
  is_public = excluded.is_public;
